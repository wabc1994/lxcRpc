# 设计模式

## 单例模式
## 动态代理模式
使用动态代理模式主要是为了让远程过程调用透明化，对通信细节进行封装，对Java来说就是使用代理
如果我们不用代理去帮我们操心那些服务寻址、网络通信的问题，我们的代码会怎样？
我们每调用一次远端服务，就要在业务代码中重复一遍那些复杂的逻辑，这肯定是不能接受的！
典型的代理模式是怎样的呢？
RPCProxyClient代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从RPCProxyClient获得服务提供方的接口，当执行helloWorldService.sayHello("test")方法时就会调用invoke方法。
```java

public class RPCProxyClient implements java.lang.reflect.InvocationHandler{
    private Object obj;
    public RPCProxyClient(Object obj){
        this.obj = obj;
    }
    /**
    * 得到代理对象
    * /
    *
*/
    public static Object getProxy(Object obj){
            return java.lang.reflect.Proxy.newProxyInstance(obj.getClass().getClassLoader(),
                   obj.getClass().getInterfaces(), new RPCProxyClient(obj));
         }
         /**
         17      * 调用此方法执行
         18      */
            
            
            
             public Object invoke(Object proxy, Method method, Object[] args)
                    throws Throwable {
                  //结果参数;
                  Object result = new Object();
                 // ...执行通信相关逻辑
                  // ...
                 return result;
              }
          }
         

```
[参考链接](https://blog.csdn.net/u012422829/article/details/78378119)
# 并发
## 集合类
ConcurrentHashMap

CountDownLatch
# 线程池
ThreadLocalExcutor
# 原子操作
# 锁操作基本情况
## ReenTreetLock
# 基本代码逻辑
POJO 需要描述一下，它们分别是RpcRequest与RpcResponse。
## 同步异步
从调用过程来说，可以分为同步通信和异步通信RPC
同步RPC：指客户端发起调用后，必须等待调用执行结果并返回结果
异步RPC：指客户方调用后不关心执行结果返回，如果客户端需要结果，可用通过提供异步 callback 回调获取返回信息。大部分 RPC 框架都同时支持这两种方式的调用。（需要的时候才调用即可）
      

# 
[参考链接](https://my.oschina.net/huangyong/blog/361751)