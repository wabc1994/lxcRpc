# 设计模式

## 单例模式
## 动态代理模式
使用动态代理模式主要是为了让远程过程调用透明化，对通信细节进行封装，对Java来说就是使用代理
如果我们不用代理去帮我们操心那些服务寻址、网络通信的问题，我们的代码会怎样？
我们每调用一次远端服务，就要在业务代码中重复一遍那些复杂的逻辑，这肯定是不能接受的！
典型的代理模式是怎样的呢？
RPCProxyClient代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从RPCProxyClient获得服务提供方的接口，当执行helloWorldService.sayHello("test")方法时就会调用invoke方法。

``java
public class RPCProxyClient implements java.lang.reflect.InvocationHandler{
    private Object obj;
    public RPCProxyClient(Object obj){
        this.obj = obj;
    }
    /**
    * 得到代理对象
    * /
    *
*/
    public static Object getProxy(Object obj){
            return java.lang.reflect.Proxy.newProxyInstance(obj.getClass().getClassLoader(),
                   obj.getClass().getInterfaces(), new RPCProxyClient(obj));
         }
         /**
         17      * 调用此方法执行
         18      */
            
            
            
             public Object invoke(Object proxy, Method method, Object[] args)
                    throws Throwable {
                  //结果参数;
                  Object result = new Object();
                 // ...执行通信相关逻辑
                  // ...
                 return result;
              }
          }
         
```
[参考链接](https://blog.csdn.net/u012422829/article/details/78378119)
# 并发
主要是设计线程安全的类型问题，线程变量共享等问题
## 集合类

### ConcurrentHashMap


同步hashmap的实现，与Hashtable的比较，减小了锁的力度，提高了性能.


### CountDownLatch
其实CountDownLatch 和CyclicBarrie 实现的东西都是一样的，完成的线程等待未完成的线程，c是计数机制，当计数器为09

CyclicBarrier就象它名字的意思一样，可看成是个障碍， 所有的线程必须到齐后才能一起通过这个障碍。

一句话理解就是线程之间进行通信的一种工具，实现了同步机制，就类似notify(), wait()等的线程进行同步的机制一样

### ThreadLocal
其实这个东西好像，去商城买东西一样，存包，线程就是你的储物柜，每个储物柜放着你的东西（本地变量），别人没有办法可以干扰你使用该变量，你可以使用该保险柜随时存储你自己的变量，

别人干扰不你的变量，相当于变量不可见模型吧

>The ThreadLocal class is a class that stores a variable in the Thread object of the current running thread, hence, while each thread can share the same ThreadLocal instance, they are not really sharing the underlying variable at all. 


不同线程可以共享一个threadLocal变量(使用同一个东西)， 但是里面存储的变量是不共享的


# 线程池
ThreadLocalExcutor


# 原子操作



# 锁操作基本情况
## ReenTreetLock



# 基本代码逻辑
POJO 需要描述一下，它们分别是RpcRequest与RpcResponse。



## 同步异步
从调用过程来说，可以分为同步通信和异步通信RPC
同步RPC：指客户端发起调用后，必须等待调用执行结果并返回结果
异步RPC：指客户方调用后不关心执行结果返回，如果客户端需要结果，可用通过提供异步 callback 回调获取返回信息。大部分 RPC 框架都同时支持这两种方式的调用。（需要的时候才调用即可）
  
   

# 
[参考链接](https://my.oschina.net/huangyong/blog/361751)